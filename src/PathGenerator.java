import java.util.ArrayList;

public class PathGenerator
{
    // The original graph in order to have information about node types
    private Hypergraph graph;
	
	// Diameter of the incoming grapphl heuristic to stop processing (if we get into a cycle).
    private final int GRAPH_DIAMETER;

	public PathGenerator(Hypergraph g)
    {
        this.graph = g;
		
		// Use the number of vertices as a heuristic diameter.
        GRAPH_DIAMETER = g.vertices.size();
    }

    //
    // Given a start node, construct a path using reachability analysis to construct a path from start template node back to leaves.
    // Forward paths are generated by following forward edges in reverse
    //
    public void GeneratePathBackwardToLeaves(PathHashMap memoizedPaths,
                                             HyperedgeMultiMap edgeDatabase,
											 int goal)
    {
        // Although this returns the set of paths, we can still acquire them through the PathHashMap
        generateAllMaximalPathsFrom(memoizedPaths, edgeDatabase, goal);
    }

    //
    // Generate ALL maximal paths from the given start node (note, each incoming basic edge results in a maximal path).
    // This gives soundness of generating paths from given nodes, but lacks
    // completeness by not generating all of the sub-paths along the way
    //
    //
    // From this node, generate all paths backward.
    // Do so by generating simple paths first (in a depth-first manner)
    //
    private ArrayList<Path> generateAllMaximalPathsFrom(PathHashMap memoizedPaths,
                                                        HyperedgeMultiMap edgeDatabase, int node)
    {
        // If we have already generated paths, no need to regenerate
        if (memoizedPaths.hasNodeBeenGenerated(node)) return memoizedPaths.get(node);

        // For all edges, create base paths and add them all to the database
        ArrayList<PebbledHyperedge> edges = null;
        try {
            edges = edgeDatabase.getBasedOnGoal(node);
        } catch (Exception e) { e.printStackTrace(); }
        
        // If there are no edges, this is a 'root' node (has no predecessors)
        if (edges == null || edges.isEmpty())
        {
            // We've successfully generated all the paths for this node: zero paths
            memoizedPaths.setGenerated(node);
            return new ArrayList<Path>();
        }

        //
        // Create all the base paths consisting of only one edge and add to the database
        ArrayList<Path> basepaths = new ArrayList<Path>();
        for (PebbledHyperedge edge : edges)
        {
            basepaths.add(new Path(edge));
        }

		// For all of the base paths, generate backward
        for (Path basepath : basepaths)
        {
            GenerateMaximalPathFromSingleEdge(memoizedPaths, edgeDatabase, basepath);
        }

        // We've successfully generated all the paths for this node
        memoizedPaths.setGenerated(node);

        // Return all the generated paths from this node
        return memoizedPaths.get(node);
    }

    //
    // For all given nodes in this path, generate the single maximal path
    //
    // This is done in a convoluted way to speed up execution since we need to combine in the size of the powerset of cardinality of givens
    //
    private void GenerateMaximalPathFromSingleEdge(PathHashMap memoizedPaths,
                                                   HyperedgeMultiMap edgeDatabase,
                                                   Path basepath)
    {
        // Create all simple paths by pursuing only a single path backward in the givens: append
        // all paths from a given to the base path
        //
        //           |
        //           v  
        //         given    __
        //           |        |
        //           v        |  basepath
        //          goal    __|
        //
        // Acquire all of the paths for the singleton sets of the powerset for all of the givens of this path
		//
        ArrayList<Integer> givens = basepath.getStartNodes();
        ArrayList<Path>[] singletonMapToNewPaths = new ArrayList[givens.size()];
        ArrayList<Path>[] singletonMapToOriginalPaths = new ArrayList[givens.size()];
        boolean genNewPaths = false;
        for (int g = 0; g < givens.size(); g++)
        {
            // Acquire the original paths and save them
            singletonMapToOriginalPaths[g] = generateAllMaximalPathsFrom(memoizedPaths, edgeDatabase, givens.get(g));
            if (singletonMapToOriginalPaths[g] == null) singletonMapToOriginalPaths[g] = new ArrayList<Path>();

            // Using the original paths, append them to the base path
            singletonMapToNewPaths[g] = new ArrayList<Path>();

            // Append all of these given paths to the base path
            for (Path path : singletonMapToOriginalPaths[g])
            {
                Path basePathCopy = new Path(basepath);
                basePathCopy.append(edgeDatabase, path);
                //memoizedPaths.put(basePathCopy);
                singletonMapToNewPaths[g].add(basePathCopy);
                genNewPaths = true;
            }
        }

        // If we did not perform any appending, we have reached a maximal situation
        // Add the maximal path to the database
        if (!genNewPaths)
        {
            // Determine suppression now to mitigate number of paths added
            //basepath.DetermineSuppressedGivens(graph);
            memoizedPaths.put(basepath);
            return;
        }

        //
        // Stitch together all of the possible combinations of maximal paths
        //
        //    |  |        |
        //    |  |        |
        //    v  v        v
        //   g_1 g_2 ... g_n   __
        //           |           |  basepath
        //           v           |
        //         target      __|
        //
        //
        // We are looking for the maximal set of paths; therefore, we don't need all combinations.
        // What we do require is the combining of all generated paths with the base path.
        //
        // Find all the sets of populated new paths
        ArrayList<Integer> populatedIndices = new ArrayList<Integer>();
        for (int index = 0; index < singletonMapToNewPaths.length; index++)
        {
            if (!singletonMapToNewPaths[index].isEmpty()) populatedIndices.add(index);
        }

		//
		// Construct paths for all unpopulated indices
		//
		ArrayList<Path> maximalPaths = new ArrayList<Path>(singletonMapToNewPaths[populatedIndices.get(0)]);
        populatedIndices.remove(0);  // Prime the pump with the first element.
        for (int index : populatedIndices)
        {
            ArrayList<Path> tmpMaximalPaths = new ArrayList<Path>();
            for (Path singleton : singletonMapToOriginalPaths[index])
            {
                for (Path path : maximalPaths)
                {
                    Path pathCopy = new Path(path);

                    // It is possible for a path to have been created which deduced further information with an additional edge;
                    // that is, a given node was pushed into the path of the path. Hence, no need to append in this situation
                    if (path.getStartNodes().contains(singleton.getGoal()))
                    {
                        pathCopy.append(edgeDatabase, singleton);
                    }
                    tmpMaximalPaths.add(pathCopy);
                }
            }
            maximalPaths = tmpMaximalPaths;
        }

        // Add all the maximal paths to the database
        for (Path path : maximalPaths)
        {
            // Determine suppression now to mitigate number of paths added
            //path.DetermineSuppressedGivens(graph);
            memoizedPaths.put(path);
        }
    }
}